% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compile_grammar.R
\name{compile_grammar}
\alias{compile_grammar}
\title{Compile a Nearley grammar string and return parser function}
\usage{
compile_grammar(nearley_string)
}
\arguments{
\item{nearley_string}{character string of a Nearley grammar or a path to a .ne file}
}
\description{
Compile a Nearley grammar string and return parser function
}
\examples{
# 'Hello world' demo:
parse_string <- compile_grammar('sequence -> "x" "y" "z"')
parse_string("xyz")

# A more complete demo:
# 1. Read a lexicon and group lines using zoo:na.locf0()
lexicon_df <-
system.file("extdata", "error-french.txt", package = "tidylex") \%>\%
    read_lexicon(regex = "\\\\\\\\([a-z]+)\\\\s(.*)", into  = c("code", "value")) \%>\%
    mutate(lx_line = ifelse(code == "lx", line, NA) \%>\% zoo::na.locf0())

# 2. Define and compile a Nearley grammar to test code sequences
headword_parser <-  compile_grammar('
    headword -> "lx" _ "ps" _ "de" _:? examples:?

    examples -> ("xv" _ "xe" _:?):+

    _ -> " "
')

# 3. Form the code sequence strings and test them against the grammar
lexicon_df \%>\%
    filter(!is.na(code)) \%>\%
    group_by(lx_line) \%>\%
    summarise(code_sequence = paste0(code, collapse = " ")) \%>\%
    rowwise() \%>\%
    mutate(parsed_sequence  = headword_parser(code_sequence, stop_on_error = FALSE)) \%>\%
    # Remove successful parse trees (which are lists, and retain only error message strings)
    filter(!is.list(parsed_sequence)) \%>\%
    mutate(parsed_sequence = unlist(parsed_sequence))
}
